# README #

This repository contains a Van Emde Boas tree written in D. It operates on unique integer keys. 

See

https://en.wikipedia.org/wiki/Van_Emde_Boas_tree

and 

Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Third Edition. MIT Press, 2009. ISBN 978-0-262-53305-8. Chapter 20: The van Emde Boas tree, pp. 531â€“560.

Further helpful source was the C++ implementation found here, 
http://www.keithschwarz.com/interesting/code/van-emde-boas-tree/
where the idea of bit operations for the leaf nodes is taken from. 

Example usage: 

```
import vebtree; 

enum baseSize(T : A!s, alias A, int s) = s;

void main()
{
    import std.random : unpredictableSeed, uniform; 
    
    /*
    The creation could be long, if number generated by unpredictableSeed is large, 
    but the example works even for (1UL << 32) - 1
    */
    auto root = vebRoot(unpredictableSeed); // create the tree structure. 
    const rndNum = uniform(0, root.universe); // ... and some data

    import std.math : nextPow2; 
    assert(root.capacity == (root.universe - 1).nextPow2);

    root.insert(rndNum); 
    assert(root.prev(rndNum) == size_t.max); 
    assert(root.next(rndNum) == size_t.max); 
    assert(root.front == root.back); 
    assert(root.length == 1); 
    auto root2 = root.dup; 
    root2.remove(rndNum); 
    assert(root2.empty); 
    assert(root2.length == 0); 
    assert(rndNum in root); 
    assert(root == root()); 
    assert(root[].front == 0); 
    assert(root[].back == root.universe); 
    
    import std.range : isBidirectionalRange; 
    static assert(isBidirectionalRange!(typeof(root[])));

    root.universe < baseSize!(typeof(root)) ? assert(root.isLeaf) : assert(!root.isLeaf);
    foreach(el; root) assert(el == rndNum);     
}
```

Copyright: Copyright (c) 2016- Alexander Orlov. All rights reserved.

License: https://opensource.org/licenses/MIT, MIT License

Author: Alexander Orlov, sascha.orlov@gmail.com